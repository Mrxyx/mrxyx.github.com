<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Butterknife使用及源码学习]]></title>
    <url>%2F2017%2F06%2F09%2FButterKnife%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本篇文章会讲解ButterKnife框架的使用（当前版本为8.6.0），注解的概念用法及分类，并且会通过ButterKnife源码学习更加深入的了解注解。 前言最近略微有点忙，之前说好的RN实践项目和面向对象的学习一度被搁浅😪，我尽量抓紧点时间吧。趁着周末忙中偷闲，来学习下依赖注解框架butterKnife，当前最新版本为8.6.0，源码github地址为这里。 ButterKnife使用添加依赖1234dependencies &#123; compile &apos;com.jakewharton:butterknife:8.6.0&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.6.0&apos;&#125; 官方使用示例1234567891011121314151617class ExampleActivity extends Activity &#123; @BindView(R.id.user) EditText username; @BindView(R.id.pass) EditText password; @BindString(R.string.login_error) String loginErrorMessage; @OnClick(R.id.submit) void submit() &#123; // TODO call server... &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.simple_activity); ButterKnife.bind(this); // TODO Use fields... &#125;&#125; 当然可以使用的注解有很多，下载源码可看到所有可以添加的注解如下 如果以上的注解你觉得使用起来还是不够通畅，还需要在代码中写@bind之类的注解，那么你还可以使用AS插件来辅助注解代码的生成，插件的名字和安装如下图所示插件的使用，如下图 刚开始接触butterKnife的时候，只是觉得使用起来好爽啊，终于告别了findviewbyid这种体力活了，飞一般的感觉。但是butterKnife是如何实现的呢？那么接下来，让我们搞起来吧。致敬大神🙏。 需要了解的知识下面列出的知识点，如有疑问强烈建议大家查看1 Java注解2 Java注解处理器(这里有英文原版)3 Java反射机制(查看本站Java反射学习实践)4 android Gradle2.2发布更新提供的annotationProcessor功能（之前的APT）其实学习完源码之后，你才会了解到JakeWharton大神的英雄池到底有多深！ 注解虽然上面建议大家去了解Java注解和注解处理器相关知识，但是还是决定简单介绍下相关知识吧💕 注解的定义注解简单来说，存储一些我们需要的数据，在编译时或者运行时调用 注解（也被成为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。 ——————摘自《Thinking in Java》page.620 注解的分类####按照Java5提供的标准来分类1 内置注解（三种） @override（大家比较常见）【表示当前方法定义将重写的父类方法，如果编写有误编译器发出错误提示】 @Deprecated【表示元素废弃】 @SuppressWarnings【关闭编译器警告】 2 元注解（四种）【负责注解其他注解】 @Retention @Target @Documented @Inherited 元注解的概念稍微有一点绕，他主要用使用自定义注解时，注解你定义的注解。额 貌似还是一样的感觉，不过可以多敲代码理解下。 @Retention 表示注解将会被运行在什么时期。 用@Retention(RetentionPolicy.CLASS)修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，但不会被虚拟机读取在运行的时候；用@Retention(RetentionPolicy.SOURCE )修饰的注解,表示注解的信息会被编译器抛弃，不会留在class文件中，注解的信息只会留在源文件中；用@Retention(RetentionPolicy.RUNTIME )修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，会被虚拟机保留在运行时，@Target 表示注解将被用在什么地方可用的ElementType参数有：CONSTRUCTOR（构造方法），FIELD（域声明），LOCAL_VARIABLE（局部变量声明），METHOD（方法声明），PACKAGE（包声明），PARAMETER（参数声明），,TYPE（类,接口,或enum） 如果你想要你的注解在运行时起作用，并且只能修饰一个类，那你可以这样定义123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyAnnotation &#123; String value();&#125; @interface 是你在定义注解的时候必须在类的开头使用的限定符 按照取值的方式分类1 运行时注解在程序运行时可以使用。如何在运行时使用呢？当然是利用反射。retrofit框架如果查看过源码，你会发现它使用的就是运行时注解。 2 编译时注解反射由于它的消耗较大，所以一直以来被诟病，所以。。。，那么如何使用编译时注解呢？那么下面需要了解下注解处理器的概念 注解处理器(本小节摘自Jlog`s Java注解处理器)注解处理器概念注解处理器（Annotation Processor）是javac的一个工具，它用来在编译时扫描和处理注解（Annotation）。你可以对自定义注解，并注册相应的注解处理器。 注解处理器的作用 一个注解的注解处理器，以Java代码（或者编译过的字节码）作为输入，生成文件（通常是.java文件）作为输出。这具体的含义什么呢？你可以生成Java代码！这些生成的Java代码是在生成的.java文件中，所以你不能修改已经存在的Java类，例如向已有的类中添加方法。这些生成的Java文件，会同其他普通的手动编写的Java源代码一样被javac编译。 虚处理器AbstractProcessor123456789101112131415public class MyProcessor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment env)&#123; &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) &#123; &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; &#125;&#125; init(ProcessingEnvironment env): 每一个注解处理器类都必须有一个空的构造函数。然而，这里有一个特殊的init()方法，它会被注解处理工具调用，并输入ProcessingEnviroment参数。ProcessingEnviroment提供很多有用的工具类Elements, Types和Filer。后面我们将看到详细的内容。 process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env): 这相当于每个处理器的主函数main()。你在这里写你的扫描、评估和处理注解的代码，以及生成Java文件。输入参数RoundEnviroment，可以让你查询出包含特定注解的被注解元素。后面我们将看到详细的内容。 getSupportedAnnotationTypes(): 这里你必须指定，这个注解处理器是注册给哪个注解的。注意，它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。换句话说，你在这里定义你的注解处理器注册到哪些注解上。 getSupportedSourceVersion(): 用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()。然而，如果你有足够的理由只支持Java 6的话，你也可以返回SourceVersion.RELEASE_6。我推荐你使用前者。 注册处理器你可能会问，我怎样将处理器MyProcessor注册到javac中。你必须提供一个.jar文件。就像其他.jar文件一样，你打包你的注解处理器到此文件中。并且，在你的jar中，你需要打包一个特定的文件javax.annotation.processing.Processor到META-INF/services路径下。所以，你的.jar文件看起来就像下面这样： MyProcessor.jar com example MyProcessor.class META-INF services javax.annotation.processing.Processor 打包进MyProcessor.jar中的javax.annotation.processing.Processor的内容是，注解处理器的合法的全名列表，每一个元素换行分割：1com.example.MyProcessor 把MyProcessor.jar放到你的builpath中，javac会自动检查和读取javax.annotation.processing.Processor中的内容，并且注册MyProcessor作为注解处理器。若对上述概念有疑问，请查看原文链接 其实如果看到这里，我猜你会说TMD，没见你分析一句源码就在撤这些概念了，兄弟放下西瓜刀，先听我说，其实如果上述概念你都明白了，那么ButterKnife的源码你阅读起来完全毫无压力。 ButterKnife源码项目结构开始我们的源码分析，首先，源代码项目结构见下图可以看到项目结构十分的明确🤸 蓝色框圈起的项目为android library 红色框圈起的项目为Java library 黄色框圈起的项目为demo A 蓝色框的项目我们在dependencies中添加。提供给我们使用的API。 B 红色框的项目比较多，依次来解释 butterknife-annotations; 定义的注解（项目结构见下图） butterknife-compiler；编译时用到的注解的处理器（important），细心的同学可能发现我们在项目中使用butterKnife时添加依赖的时候导入的就有这个项目 butterknife-gradle-plugin；自定义的gradle插件，辅助生成有关代码 butterknife-lint；项目的lint检查 C 黄色框内的demo项目暂时就不多做解释，相信大家都能看懂 ButterKnife源码学习开始我们的正式的学习吧！新建工程，添加ButterKnife依赖，界面很简单，包含一个TextView和IamgeView，使用ButterKnife进行注解。项目代码如下一键生成真的是麻瓜式编程了~.~控件的初始化和点击事件都已成功绑定了，在setContentView(…)下，多出了ButterKnife.bind(this); @BindView让我们首先查看下@BindView的注解是如何定义的吧。点击进入源码查看12345@Retention(CLASS) @Target(FIELD)public @interface BindView &#123; /** View ID to which the field will be bound. */ @IdRes int value();&#125; 通过上一节注解知识的学习，我们知道当前注解为编译时注解只注解参数喽，既然是编译时注解那么肯定存在注解处理器。我们在添加依赖的时候你就会发现除了ButterKnife的依赖，你同时也添加了注解处理器依赖1`annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.6.0&apos;` AbstractProcessor注解处理器了解完@BindView源码后，接着让我们来查看下注解处理器是如何编写的。ButterKnifeProcessor类的源码较长，这里就不贴出来了，会跳出主要的方法进行分析，如果需要，类路径为butterknife.compiler.ButterKnifeProcessor可自行查看。 1先来查看init()方法 1234567891011121314151617181920212223@Override public synchronized void init(ProcessingEnvironment env) &#123; super.init(env); String sdk = env.getOptions().get(OPTION_SDK_INT); if (sdk != null) &#123; try &#123; this.sdk = Integer.parseInt(sdk); &#125; catch (NumberFormatException e) &#123; env.getMessager() .printMessage(Kind.WARNING, "Unable to parse supplied minSdk option '" + sdk + "'. Falling back to API 1 support."); &#125; &#125; elementUtils = env.getElementUtils(); typeUtils = env.getTypeUtils(); filer = env.getFiler(); try &#123; trees = Trees.instance(processingEnv); &#125; catch (IllegalArgumentException ignored) &#123; &#125; &#125; 首先看到的就是各种try{}catch(){}，由此可见一个好的框架容错是真的厉害，基本上大部分的代码都是来处理兼容。此方法中主要获取了一些辅助类，包括元素辅助类，类型辅助类，文件辅助类等。 2接着查看process()方法。 1234567891011121314151617@Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env); for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingSet binding = entry.getValue(); JavaFile javaFile = binding.brewJava(sdk); try &#123; javaFile.writeTo(filer); &#125; catch (IOException e) &#123; error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage()); &#125; &#125; return false;&#125; 这个方法就比较重要了，但是代码确如此的简单🙃，首先调用了findAndParseTargets方法返回一个Map值存放元素和对应的Bindingset,至于BindingSet是什么，暂且不表，然后遍历Map获得各个元素（注解），调用javapoet库提供的方法自动生成java类（若需了解javapoet可自行学习）。 首先我们来查看findAndParseTargets方法，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;(); Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;(); scanForRClasses(env); // Process each @BindArray element. for (Element element : env.getElementsAnnotatedWith(BindArray.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceArray(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindArray.class, e); &#125; &#125; // Process each @BindBitmap element. for (Element element : env.getElementsAnnotatedWith(BindBitmap.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceBitmap(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindBitmap.class, e); &#125; &#125; // Process each @BindBool element. for (Element element : env.getElementsAnnotatedWith(BindBool.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceBool(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindBool.class, e); &#125; &#125; // Process each @BindColor element. for (Element element : env.getElementsAnnotatedWith(BindColor.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceColor(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindColor.class, e); &#125; &#125; // Process each @BindDimen element. for (Element element : env.getElementsAnnotatedWith(BindDimen.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceDimen(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindDimen.class, e); &#125; &#125; // Process each @BindDrawable element. for (Element element : env.getElementsAnnotatedWith(BindDrawable.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceDrawable(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindDrawable.class, e); &#125; &#125; // Process each @BindFloat element. for (Element element : env.getElementsAnnotatedWith(BindFloat.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceFloat(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindFloat.class, e); &#125; &#125; // Process each @BindInt element. for (Element element : env.getElementsAnnotatedWith(BindInt.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceInt(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindInt.class, e); &#125; &#125; // Process each @BindString element. for (Element element : env.getElementsAnnotatedWith(BindString.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceString(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindString.class, e); &#125; &#125; // Process each @BindView element. for (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123; // we don't SuperficialValidation.validateElement(element) // so that an unresolved View type can be generated by later processing rounds try &#123; parseBindView(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindView.class, e); &#125; &#125; // Process each @BindViews element. for (Element element : env.getElementsAnnotatedWith(BindViews.class)) &#123; // we don't SuperficialValidation.validateElement(element) // so that an unresolved View type can be generated by later processing rounds try &#123; parseBindViews(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindViews.class, e); &#125; &#125; // Process each annotation that corresponds to a listener. for (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123; findAndParseListener(env, listener, builderMap, erasedTargetNames); &#125; // Associate superclass binders with their subclass binders. This is a queue-based tree walk // which starts at the roots (superclasses) and walks to the leafs (subclasses). Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries = new ArrayDeque&lt;&gt;(builderMap.entrySet()); Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;(); while (!entries.isEmpty()) &#123; Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst(); TypeElement type = entry.getKey(); BindingSet.Builder builder = entry.getValue(); TypeElement parentType = findParentType(type, erasedTargetNames); if (parentType == null) &#123; bindingMap.put(type, builder.build()); &#125; else &#123; BindingSet parentBinding = bindingMap.get(parentType); if (parentBinding != null) &#123; builder.setParent(parentBinding); bindingMap.put(type, builder.build()); &#125; else &#123; // Has a superclass binding but we haven't built it yet. Re-enqueue for later. entries.addLast(entry); &#125; &#125; &#125; return bindingMap; &#125; 这里根据不同元素类型，调用不同的pareseBind..方法，我们仅仅查看和BindView相关的代码，其他部分代码原理相似。12345678910// Process each @BindView element.for (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123;// we don't SuperficialValidation.validateElement(element) // so that an unresolved View type can be generated by later processing rounds try &#123; parseBindView(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindView.class, e); &#125;&#125; 接着看调用了pareseBindView12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, Set&lt;TypeElement&gt; erasedTargetNames) &#123; TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); // Start by verifying common generated code restrictions. boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element) || isBindingInWrongPackage(BindView.class, element); // Verify that the target type extends from View. TypeMirror elementType = element.asType(); if (elementType.getKind() == TypeKind.TYPEVAR) &#123; TypeVariable typeVariable = (TypeVariable) elementType; elementType = typeVariable.getUpperBound(); &#125; Name qualifiedName = enclosingElement.getQualifiedName(); Name simpleName = element.getSimpleName(); if (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) &#123; if (elementType.getKind() == TypeKind.ERROR) &#123; note(element, "@%s field with unresolved type (%s) " + "must elsewhere be generated as a View or interface. (%s.%s)", BindView.class.getSimpleName(), elementType, qualifiedName, simpleName); &#125; else &#123; error(element, "@%s fields must extend from View or be an interface. (%s.%s)", BindView.class.getSimpleName(), qualifiedName, simpleName); hasError = true; &#125; &#125; if (hasError) &#123; return; &#125; // Assemble information on the field. int id = element.getAnnotation(BindView.class).value(); BindingSet.Builder builder = builderMap.get(enclosingElement); QualifiedId qualifiedId = elementToQualifiedId(element, id); if (builder != null) &#123; String existingBindingName = builder.findExistingBindingName(getId(qualifiedId)); if (existingBindingName != null) &#123; error(element, "Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)", BindView.class.getSimpleName(), id, existingBindingName, enclosingElement.getQualifiedName(), element.getSimpleName()); return; &#125; &#125; else &#123; builder = getOrCreateBindingBuilder(builderMap, enclosingElement); &#125; String name = simpleName.toString(); TypeName type = TypeName.get(elementType); boolean required = isFieldRequired(element); builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required)); // Add the type-erased version to the valid binding targets set. erasedTargetNames.add(enclosingElement);&#125; 上来就又是各种校验代码。这些都不重要，哦！不对第一句1boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element)|| isBindingInWrongPackage(BindView.class, element); 校验了修饰符，如果存在static private则抛异常，所以说我们在自己写注解的时候，要注意修饰符。比较重要的地方有1builder = getOrCreateBindingBuilder(builderMap, enclosingElement); 此方法中调用了getOrCreateBindingBuilder方法123456789private BindingSet.Builder getOrCreateBindingBuilder( Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, TypeElement enclosingElement) &#123; BindingSet.Builder builder = builderMap.get(enclosingElement); if (builder == null) &#123; builder = BindingSet.newBuilder(enclosingElement); builderMap.put(enclosingElement, builder); &#125; return builder; &#125; BuilderSet出现在这里，那么让我们查看BuilderSet创建调用的方法newBuilder代码如下1234567891011121314151617181920static Builder newBuilder(TypeElement enclosingElement) &#123; TypeMirror typeMirror = enclosingElement.asType(); boolean isView = isSubtypeOfType(typeMirror, VIEW_TYPE); boolean isActivity = isSubtypeOfType(typeMirror, ACTIVITY_TYPE); boolean isDialog = isSubtypeOfType(typeMirror, DIALOG_TYPE); TypeName targetType = TypeName.get(typeMirror); if (targetType instanceof ParameterizedTypeName) &#123; targetType = ((ParameterizedTypeName) targetType).rawType; &#125; String packageName = getPackage(enclosingElement).getQualifiedName().toString(); String className = enclosingElement.getQualifiedName().toString().substring( packageName.length() + 1).replace('.', '$'); ClassName bindingClassName = ClassName.get(packageName, className + "_ViewBinding"); boolean isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL); return new Builder(targetType, bindingClassName, isFinal, isView, isActivity, isDialog); &#125; 创建了一个builder，builder含有的参数有targetType，bindingClassName，isFinal，isView，isActivity，isDialog。参数中的bindingClassName生成需要注意下1ClassName bindingClassName = ClassName.get(packageName, className + "_ViewBinding"); 下面就是从map中（有则取缓存，没有则创建），取出被注解变量的名称，类型，id等保存到生成的FieldViewBinding实体中，并将实体保存到build中。ok，抽根93年的雪茄压压惊。gogogogo接下来我们查看process()中的其他方法，1234567891011for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingSet binding = entry.getValue(); JavaFile javaFile = binding.brewJava(sdk); try &#123; javaFile.writeTo(filer); &#125; catch (IOException e) &#123; error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage()); &#125; &#125; 通过BindingSet获得binding,调用binding.brewJava(sdk);方法生成javaFile，通过JavaFile生成了java类，来查看下brewJava方法12345JavaFile brewJava(int sdk) &#123; return JavaFile.builder(bindingClassName.packageName(), createType(sdk)) .addFileComment("Generated code from Butter Knife. Do not modify!") .build(); &#125; 这里的bindingClassName就是上面分析的newBuilder方法中赋值的bindingClassName.1ClassName bindingClassName = ClassName.get(packageName, className + "_ViewBinding"); 也就是说会生成一个后缀名为_ViewBinding的java类。这个类位于在/build/generated/source/apt/debud/xxxx/目录下，xxx是你对应的包名。下面为之前demo编译后生成的后缀名为_ViewBinding的java类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity_ViewBinding implements Unbinder &#123; private MainActivity target; private View view2131427422; private View view2131427423; @UiThread public MainActivity_ViewBinding(MainActivity target) &#123; this(target, target.getWindow().getDecorView()); &#125; @UiThread public MainActivity_ViewBinding(final MainActivity target, View source) &#123; this.target = target; View view; view = Utils.findRequiredView(source, R.id.testTv, "field 'testTv' and method 'onViewClicked'"); target.testTv = Utils.castView(view, R.id.testTv, "field 'testTv'", TextView.class); view2131427422 = view; view.setOnClickListener(new DebouncingOnClickListener() &#123; @Override public void doClick(View p0) &#123; target.onViewClicked(p0); &#125; &#125;); view = Utils.findRequiredView(source, R.id.testIv, "field 'testIv' and method 'onViewClicked'"); target.testIv = Utils.castView(view, R.id.testIv, "field 'testIv'", ImageView.class); view2131427423 = view; view.setOnClickListener(new DebouncingOnClickListener() &#123; @Override public void doClick(View p0) &#123; target.onViewClicked(p0); &#125; &#125;); &#125; @Override @CallSuper public void unbind() &#123; MainActivity target = this.target; if (target == null) throw new IllegalStateException("Bindings already cleared."); this.target = null; target.testTv = null; target.testIv = null; view2131427422.setOnClickListener(null); view2131427422 = null; view2131427423.setOnClickListener(null); view2131427423 = null; &#125;&#125; 那么这个类是如何被调用的呢？骚年上面我们分析了注解的生成但是有一个重要的方法被忽视了，算了，我还是重新贴下之前我们创建的项目代码吧，太长了省得大家找了123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.testTv) TextView testTv; @BindView(R.id.testIv) ImageView testIv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); &#125; @OnClick(&#123;R.id.testTv, R.id.testIv&#125;) public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.testTv: break; case R.id.testIv: break; &#125; &#125;&#125; attent please!ButterKnife.bind(this);就是这个方法，来查看下bind方法进行了什么样的骚作吧，123456789101112131415161718192021222324252627282930313233343536 @NonNull @UiThread public static Unbinder bind(@NonNull Activity target) &#123; View sourceView = target.getWindow().getDecorView(); return createBinding(target, sourceView); &#125;``` 调用了createBinding方法，继续```Javaprivate static Unbinder createBinding(@NonNull Object target, @NonNull View source) &#123; Class&lt;?&gt; targetClass = target.getClass(); if (debug) Log.d(TAG, "Looking up binding for " + targetClass.getName()); Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass); if (constructor == null) &#123; return Unbinder.EMPTY; &#125; //noinspection TryWithIdenticalCatches Resolves to API 19+ only type. try &#123; return constructor.newInstance(target, source); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException("Unable to invoke " + constructor, e); &#125; catch (InstantiationException e) &#123; throw new RuntimeException("Unable to invoke " + constructor, e); &#125; catch (InvocationTargetException e) &#123; Throwable cause = e.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException("Unable to create binding instance.", cause); &#125; &#125; 这里主要看下调用的findBindingConstructorForClass方法，此方法返回了一个Constructor，然后通过反射生成了这个Constructor的实体，那么findBindingConstructorForClass做了什么骚作呢？1234567891011121314151617181920212223242526@Nullable @CheckResult @UiThread private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123; Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls); if (bindingCtor != null) &#123; if (debug) Log.d(TAG, "HIT: Cached in binding map."); return bindingCtor; &#125; String clsName = cls.getName(); if (clsName.startsWith("android.") || clsName.startsWith("java.")) &#123; if (debug) Log.d(TAG, "MISS: Reached framework class. Abandoning search."); return null; &#125; try &#123; Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + "_ViewBinding"); //noinspection unchecked bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class); if (debug) Log.d(TAG, "HIT: Loaded binding class and constructor."); &#125; catch (ClassNotFoundException e) &#123; if (debug) Log.d(TAG, "Not found. Trying superclass " + cls.getSuperclass().getName()); bindingCtor = findBindingConstructorForClass(cls.getSuperclass()); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException("Unable to find binding constructor for " + clsName, e); &#125; BINDINGS.put(cls, bindingCtor); return bindingCtor; &#125; 重要的方法123456Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + "_ViewBinding"); //noinspection unchecked bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);...BINDINGS.put(cls, bindingCtor); return bindingCtor; 兄弟如果此处看不太懂，推荐你(查看本站Java反射学习实践)。这里生成的Constructor为后缀名_ViewBinding的java类，即我们在编译时生成的类。也就是说ButterKnife.bind方法会调用_ViewBinding的java类的构造函数，即本此demo中的123456789101112131415161718192021222324@UiThread public MainActivity_ViewBinding(final MainActivity target, View source) &#123; this.target = target; View view; view = Utils.findRequiredView(source, R.id.testTv, "field 'testTv' and method 'onViewClicked'"); target.testTv = Utils.castView(view, R.id.testTv, "field 'testTv'", TextView.class); view2131427422 = view; view.setOnClickListener(new DebouncingOnClickListener() &#123; @Override public void doClick(View p0) &#123; target.onViewClicked(p0); &#125; &#125;); view = Utils.findRequiredView(source, R.id.testIv, "field 'testIv' and method 'onViewClicked'"); target.testIv = Utils.castView(view, R.id.testIv, "field 'testIv'", ImageView.class); view2131427423 = view; view.setOnClickListener(new DebouncingOnClickListener() &#123; @Override public void doClick(View p0) &#123; target.onViewClicked(p0); &#125; &#125;); &#125; 终于看到了熟悉的代码setOnClickListener().这里使用了回调，接着调用Utils中的方法，如下123456789101112131415161718192021222324252627282930313233... public static View findRequiredView(View source, @IdRes int id, String who) &#123; View view = source.findViewById(id); if (view != null) &#123; return view; &#125; String name = getResourceEntryName(source, id); throw new IllegalStateException("Required view '" + name + "' with ID " + id + " for " + who + " was not found. If this view is optional add '@Nullable' (fields) or '@Optional'" + " (methods) annotation."); &#125;... public static &lt;T&gt; T castView(View view, @IdRes int id, String who, Class&lt;T&gt; cls) &#123; try &#123; return cls.cast(view); &#125; catch (ClassCastException e) &#123; String name = getResourceEntryName(view, id); throw new IllegalStateException("View '" + name + "' with ID " + id + " for " + who + " was of the wrong type. See cause for more info.", e); &#125; &#125;... 我里个神啊，终于看到findViewById了 心好累。 其实说白了就是使用编译时注解，加动态生成Java类来完成一些重复操作，比如findViewVById和点击事件。但是，老铁，你这个框架源码是写的真的厉害 源码的暂时分析到这里吧，其实分析起来都不太难，主要的是学习源码中的处理问题的方式。当然还有编码风格色剂模式。 参考 JakeWharton/butterknife Jlog`s Java注解处理器 深入理解ButterKnife源码并掌握原理系列]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>注解</tag>
        <tag>Butterknife</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射学习实践]]></title>
    <url>%2F2017%2F06%2F05%2FJava%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[简单来说，Java中通过反射，可以在运行时获得程序自身的信息，并且可以操作类或对象的内部属性。 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control. 上述为Oracle官方的反射解释。 Java反射提供的功能： 1.在运行时判断任意一个对象所属的类； 2.在运行时构造任意一个类的对象； 3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 4.在运行时调用任意一个对象的方法 class类提到反射，我们需要先声明下Java中的class类,as we know,所有的java类均继承了Object类，在Object类中定义了一个getClass()方法，该方法返回一个类型为Class的对象。如下1Class testc = textField.getClass();//textField为JTextField对象 通过testc对象我们可以访问到JTextFiel的描述信息：主要描述信息如下 访问方法 返回值类型 说明 getPackage() Package对象 获得该类的存放路径 getName() String对象 该类的名称 getSuperClass() Class对象 获得该类继承的类 getInterface() Class数组 获得该类实现的所有接口 getConstructors() Constructor数组 获得所有权限为public的构造方法 getConstructor(Class&lt;?&gt;…types) Constructor对象 获得权限为public的指定的构造方法 getDeclaredConstructors() Constructor数组 获得所有的构造方法，按声明顺序返回 getDeclaredConstructor(Class&lt;?&gt;…types) Constructor对象 获得指定的构造方法 getMethods() Method数组 获得所有权限为Public的方法 getMethod(String name, Class&lt;?&gt;…types) Method对象 获得权限为Public的指定的方法 getDeclaredMethods() Method数组 获得所有的方法,按声明顺序返回 getDeclaredMethod(String name, Class&lt;?&gt;…types) Method对象 获得指定的方法 getFields() Field数组 获得所有权限为Public的成员变量 getField(String name) Field对象 获得权限为Public的指定的成员变量 getDeclaredFields() Field数组 获得所有的成员变量 getDeclaredField(String name) Method对象 获得指定的成员变量 getClasses() Class数组 获得所有权限为public的内部类 getDeclaredClasses() Class数组 获得所有内部类 getDeclaringClass() Class对象 如果该类为内部类，则返回它的成员类，否则返回null 说明:getClasses()和getMethods()会包含父类中权限为public的成员变量和方法 获得Class的其他方法12345//第一种方式： Class testc = Class.forName("JTextField"); //第二种方式： //java中每个类型都有class 属性. Class testc = JTextField.class; java提供的反射类java.lang.Class;java.lang.reflect.Constructor; java.lang.reflect.Field;java.lang.reflect.Method;java.lang.reflect.Modifier; 获得Class对象123456789101112131415161718192021222324252627package com.mrx.testreflection;/** * 反射实践类 * 2017年6月6日21:33:22 * @author Mrx */public class TestReflection &#123; public static void main(String[] args) &#123; /**获得class的方式**/ Class c1 = null; Class c2 = null; Class c3 = null; try &#123; c1 = Class.forName("com.mrx.testreflection.TestReflection"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; c2 = new TestReflection().getClass(); c3 = TestReflection.class; System.out.println(c1.getName()); System.out.println(c2.getName()); System.out.println(c3.getName()); &#125;&#125; 打印结果为123com.mrx.testreflection.TestReflectioncom.mrx.testreflection.TestReflectioncom.mrx.testreflection.TestReflection 获得对象的父类和实现的接口123456789101112131415161718192021222324package com.mrx.testreflection;import java.io.Serializable;/** * 反射实践类 * 2017年6月6日21:33:22 * @author Mrx */public class TestReflection implements Serializable &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = Class.forName("com.mrx.testreflection.TestReflection"); // 取得父类 Class&lt;?&gt; parentClass = clazz.getSuperclass(); System.out.println("父类为：" + parentClass.getName()); // 获取所有的接口 Class&lt;?&gt; intes[] = clazz.getInterfaces(); System.out.println("实现的接口有："); for (int i = 0; i &lt; intes.length; i++) &#123; System.out.println((i + 1) + "：" + intes[i].getName()); &#125; &#125;&#125; 打印结果为12父类为：java.lang.Object实现的接口有：1：java.io.Serializable 获得类中的构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.mrx.testreflection;import java.io.Serializable;import java.lang.reflect.Constructor;/** * 反射实践类 2017年6月6日21:33:22 * * @author Mrx */public class TestReflection implements Serializable &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName("com.mrx.testreflection.Person"); Constructor&lt;?&gt; cons[] = class1.getConstructors(); // 查看每个构造方法需要的参数 for (int i = 0; i &lt; cons.length; i++) &#123; Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes(); System.out.print("cons[" + i + "] ("); for (int j = 0; j &lt; clazzs.length; j++) &#123; if (j == clazzs.length - 1) System.out.print(clazzs[j].getName()); else System.out.print(clazzs[j].getName() + ","); &#125; System.out.println(")"); &#125; &#125;&#125;class Person &#123; private String name; public int age; public Person() &#123; super(); &#125; public Person(String name) &#123; super(); this.name = name; &#125; public Person(int age) &#123; super(); this.age = age; &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125;&#125; 打印结果为1234cons[0] (java.lang.String,int)cons[1] (int)cons[2] (java.lang.String)cons[3] () ###实例化一个对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.mrx.testreflection;import java.io.Serializable;import java.lang.reflect.Constructor;/** * 反射实践类 2017年6月6日21:33:22 * * @author Mrx */public class TestReflection implements Serializable &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName("com.mrx.testreflection.Person"); Person person = (Person) class1.newInstance(); person.age = 20; person.name = "Lilei"; System.out.println(person); Constructor&lt;?&gt; cons[] = class1.getConstructors(); // 查看每个构造方法需要的参数 for (int i = 0; i &lt; cons.length; i++) &#123; Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes(); System.out.print("cons[" + i + "] ("); for (int j = 0; j &lt; clazzs.length; j++) &#123; if (j == clazzs.length - 1) System.out.print(clazzs[j].getName()); else System.out.print(clazzs[j].getName() + ","); &#125; System.out.println(")"); &#125; //cons[0] (java.lang.String,int) //cons[1] (int) //cons[2] (java.lang.String) //cons[3] () Person person1 = (Person) cons[0].newInstance("Hanmeimei", 18); System.out.println(person1); Person person2= (Person) cons[1].newInstance(38); System.out.println(person2); &#125;&#125;class Person &#123; public String name; public int age; public Person() &#123; super(); &#125; public Person(String name) &#123; super(); this.name = name; &#125; public Person(int age) &#123; super(); this.age = age; &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125;&#125; 打印结果为1234567Person [name=Lilei, age=20]cons[0] (java.lang.String,int)cons[1] (int)cons[2] (java.lang.String)cons[3] ()Person [name=Hanmeimei, age=18]Person [name=null, age=38] 获取类的全部属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.mrx.testreflection;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * 反射实践类 2017年6月6日21:33:22 * * @author Mrx */public class TestReflection implements Serializable &#123; public String hello = "reflection"; private String reflection = "hello"; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("com.mrx.testreflection.TestReflection"); System.out.println("===============全部成员变量==============="); // 取得本类的全部成员变量 Field[] field = clazz.getDeclaredFields(); for (int i = 0; i &lt; field.length; i++) &#123; // 权限修饰符 int mo = field[i].getModifiers(); String priv = Modifier.toString(mo); // 属性类型 Class&lt;?&gt; type = field[i].getType(); System.out.println(priv + " " + type.getName() + " " + field[i].getName() + ";"); &#125; System.out.println("===============public成员变量==============="); // 取得本类的public成员变量 Field[] filed1 = clazz.getFields(); for (int j = 0; j &lt; filed1.length; j++) &#123; // 权限修饰符 int mo = filed1[j].getModifiers(); String priv = Modifier.toString(mo); // 属性类型 Class&lt;?&gt; type = filed1[j].getType(); System.out.println(priv + " " + type.getName() + " " + filed1[j].getName() + ";"); &#125; &#125;&#125; 打印结果为12345===============全部成员变量===============public java.lang.String hello;private java.lang.String reflection;===============public成员变量===============public java.lang.String hello; 获取类的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.mrx.testreflection;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;/** * 反射实践类 2017年6月6日21:33:22 * * @author Mrx */public class TestReflection implements Serializable &#123; public String hello = "reflection"; private String reflection = "hello"; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("com.mrx.testreflection.TestReflection"); Method method[] = clazz.getMethods(); for (int i = 0; i &lt; method.length; ++i) &#123; Class&lt;?&gt; returnType = method[i].getReturnType(); Class&lt;?&gt; para[] = method[i].getParameterTypes(); int temp = method[i].getModifiers(); System.out.print(Modifier.toString(temp) + " "); System.out.print(returnType.getName() + " "); System.out.print(method[i].getName() + " "); System.out.print("("); for (int j = 0; j &lt; para.length; ++j) &#123; System.out.print(para[j].getName() + " " + "arg" + j); if (j &lt; para.length - 1) &#123; System.out.print(","); &#125; &#125; Class&lt;?&gt; exce[] = method[i].getExceptionTypes(); if (exce.length &gt; 0) &#123; System.out.print(") throws "); for (int k = 0; k &lt; exce.length; ++k) &#123; System.out.print(exce[k].getName() + " "); if (k &lt; exce.length - 1) &#123; System.out.print(","); &#125; &#125; &#125; else &#123; System.out.print(")"); &#125; System.out.println(); &#125; &#125;&#125; 打印结果为12345678910public static void main ([Ljava.lang.String; arg0) throws java.lang.Exception public final void wait () throws java.lang.InterruptedException public final void wait (long arg0,int arg1) throws java.lang.InterruptedException public final native void wait (long arg0) throws java.lang.InterruptedException public boolean equals (java.lang.Object arg0)public java.lang.String toString ()public native int hashCode ()public final native java.lang.Class getClass ()public final native void notify ()public final native void notifyAll () 反射调用类的方法123456789101112131415161718192021222324252627282930313233package com.mrx.testreflection;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;/** * 反射实践类 2017年6月6日21:33:22 * * @author Mrx */public class TestReflection implements Serializable &#123; public String hello = "reflection"; private String reflection = "hello"; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("com.mrx.testreflection.TestReflection"); Method method = clazz.getMethod("eatMeat"); method.invoke(clazz.newInstance()); method = clazz.getMethod("eat", String.class); method.invoke(clazz.newInstance(), "shit"); &#125; public void eatMeat() &#123; System.out.println("Java 反射机制 - 调用类的方法eatMeat"); &#125; public void eat(String food) &#123; System.out.println("Java 反射机制 - 调用类的方法eat"+food); &#125;&#125; 打印结果12Java 反射机制 - 调用类的方法eatMeatJava 反射机制 - 调用类的方法eatshit 反射操作类的属性123456789101112131415161718192021222324252627package com.mrx.testreflection;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;/** * 反射实践类 2017年6月6日21:33:22 * * @author Mrx */public class TestReflection implements Serializable &#123; private String proprety = null; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("com.mrx.testreflection.TestReflection"); Object obj = clazz.newInstance(); // 可以直接对 private 的属性赋值 Field field = clazz.getDeclaredField("proprety"); field.setAccessible(true); field.set(obj, "Java反射机制"); System.out.println(field.get(obj)); &#125;&#125; 打印结果1Java反射机制 反射的动态代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.mrx.testreflection;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.Proxy;//定义项目接口interface Subject &#123; public String say(String name, int age);&#125;// 定义真实项目class RealSubject implements Subject &#123; public String say(String name, int age) &#123; return name + " " + age; &#125;&#125;class MyInvocationHandler implements InvocationHandler &#123; private Object obj = null; public Object bind(Object obj) &#123; this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this); &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object temp = method.invoke(this.obj, args); return temp; &#125;&#125;/** * 在java中有三种类类加载器。 * * 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。 * * 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jrelibext目录中的类 * * 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。 * * 如果想要完成动态代理，首先需要定义一个InvocationHandler接口的子类，已完成代理的具体操作。 * * */public class TestReflection implements Serializable &#123; private String proprety = null; public static void main(String[] args) throws Exception &#123; MyInvocationHandler demo = new MyInvocationHandler(); Subject sub = (Subject) demo.bind(new RealSubject()); String info = sub.say("Rollen", 20); System.out.println(info); &#125;&#125; 打印结果为1Rollen 20 反射的应用在泛型为Integer的ArrayList中存放一个String类型的对象。12345678910111213141516171819202122package com.mrx.testreflection;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.Proxy;import java.util.ArrayList;public class TestReflection implements Serializable &#123; private String proprety = null; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Method method = list.getClass().getMethod("add", Object.class); method.invoke(list, "Java反射机制实例。"); System.out.println(list.get(0)); &#125;&#125; 打印结果为1Java反射机制实例。 反射修改数组信息和大小123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.mrx.testreflection;import java.io.Serializable;import java.lang.reflect.Array;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.Proxy;import java.util.ArrayList;public class TestReflection implements Serializable &#123; private String proprety = null; public static void main(String[] args) throws Exception &#123; int[] temp = &#123; 1, 2, 3, 4, 5 &#125;; Class&lt;?&gt; demo = temp.getClass().getComponentType(); System.out.println("数组类型： " + demo.getName()); System.out.println("数组长度 " + Array.getLength(temp)); System.out.println("数组的第一个元素: " + Array.get(temp, 0)); Array.set(temp, 0, 100); System.out.println("修改之后数组第一个元素为： " + Array.get(temp, 0)); int[] newTemp = (int[]) arrayInc(temp, 15); print(newTemp); String[] atr = &#123; "a", "b", "c" &#125;; String[] str1 = (String[]) arrayInc(atr, 8); print(str1); &#125; // 修改数组大小 public static Object arrayInc(Object obj, int len) &#123; Class&lt;?&gt; arr = obj.getClass().getComponentType(); Object newArr = Array.newInstance(arr, len); int co = Array.getLength(obj); System.arraycopy(obj, 0, newArr, 0, co); return newArr; &#125; // 打印 public static void print(Object obj) &#123; Class&lt;?&gt; c = obj.getClass(); if (!c.isArray()) &#123; return; &#125; System.out.println("数组长度为： " + Array.getLength(obj)); for (int i = 0; i &lt; Array.getLength(obj); i++) &#123; System.out.print(Array.get(obj, i) + " "); &#125; System.out.println(); &#125;&#125; 打印结果为12345678数组类型： int数组长度 5数组的第一个元素: 1修改之后数组第一个元素为： 100数组长度为： 15100 2 3 4 5 0 0 0 0 0 0 0 0 0 0 数组长度为： 8a b c null null null null null 将反射机制应用于改善简单工厂模式的缺陷12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.mrx.testreflection;import java.io.Serializable;import java.lang.reflect.Array;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.Proxy;import java.util.ArrayList;interface Animal &#123; public abstract void eat();&#125;class Wolf implements Animal &#123; public void eat() &#123; System.out.println("wolf eat meat"); &#125;&#125;class Dog implements Animal &#123; public void eat() &#123; System.out.println("dog eat shit"); &#125;&#125;class Factory &#123; public static Animal getInstance(String ClassName) &#123; Animal animal = null; try &#123; animal = (Animal) Class.forName(ClassName).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return animal; &#125;&#125;/** * 对于普通的工厂模式当我们在添加一个子类的时候，就需要对应的修改工厂类。 当我们添加很多的子类的时候，会很麻烦。 * Java 工厂模式可以参考 * http://baike.xsoftlab.net/view/java-factory-pattern * * 现在我们利用反射机制实现工厂模式，可以在不修改工厂类的情况下添加任意多个子类。 * * 但是有一点仍然很麻烦，就是需要知道完整的包名和类名，这里可以使用properties配置文件来完成。 * * java 读取 properties 配置文件 的方法可以参考 * http://baike.xsoftlab.net/view/java-read-the-properties-configuration-file * */public class TestReflection implements Serializable &#123; public static void main(String[] args) throws Exception &#123; Animal f = null; f = Factory.getInstance("com.mrx.testreflection.Dog"); if (f != null) &#123; f.eat(); &#125; f = Factory.getInstance("com.mrx.testreflection.Wolf"); if (f != null) &#123; f.eat(); &#125; &#125;&#125; 打印结果为12dog eat shitwolf eat meat 参考JavaJava初级码农博客]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发技能导图]]></title>
    <url>%2F2017%2F06%2F05%2FAndroid%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最近参考其他人发布的android开发技能图谱，自己大概整理出来一份，供大家参考，如有遗漏，请指正。另外，吐槽下网易云跟帖审核机制是真的影响体验啊！审核时间太长啦~~~小伙伴有疑问可以发我邮件📧 右上分支主题为实际开发过程中需要使用到的技术说明：持续集成用于自动构建打包技术 右中分支主题为Android开发中的新技术 右下分支主题为Android apk优化 左侧主题为Android进阶技能（自动化测试这块暂时归为此类吧）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>android技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的基本原则]]></title>
    <url>%2F2017%2F05%2F22%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[其实决定写设计模式相关文章的时候，内心是有点忐忑的。不是那个忐忑，是那个忐忑，毕竟自己有点像墙头芦苇——头重脚轻根底浅。但是还是决定记录下自己的学习心得吧，当然文章不当之处，请各位大侠及时指正，立马修改~ 单一职责 两个完全不一样的功能不应该放在一个类中。一个类中应该是一组相关性很高的函数、数据的封装 //TODO 开闭原则 软件中的类、模块、函数等，应该对于扩展是开放的，但是对于修改是封闭的。 因此，当软件需要变化时，我们应该尽量的通过扩展的方式来实现变化，而不是通过修改已有代码来实现，不过在现实开发中，只通过继承的方式来实现升级、维护原有系统只是一个理想化的愿景，因此，在实际开发过程中，修改原有代码、扩展代码往往是同时存在的。 //TODO 里氏替换 所有引用基类的地方必须能透明的使用子类对象。只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常。 //TODO 依赖倒置 模块间的依赖通过抽象发生，实现类之间不发生直接依赖关系，其他依赖关系是通过接口或抽象类产生的。 //TODO 接口隔离 类间的依赖关系应该建立在最小的接口上。 //TODO 迪米特 一个类应该自己需要耦合或调用的类知道的最少，类的内部如何实现与调用者或依赖者没关系，调用者或者依赖者只需要知道它需要的方法即可。 //TODO]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native入门到怀疑人生（五）]]></title>
    <url>%2F2017%2F05%2F22%2FReact-Native%E5%85%A5%E9%97%A8%E5%88%B0%E6%80%80%E7%96%91%E4%BA%BA%E7%94%9F%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[欢迎收听React Native系列，基于Window10,偏向于Android端的React Native。上一章React Native入门到怀疑人生（四）我们已经讲解了flexbox布局，控件宽高相关知识，本章节将讲解RN的SrollView,ListView,和网络相关知识。本章将使用ES6语法。文章不当之处，希望大家不吝赐教，多谢！ ScrollView哇！好熟悉啊！没错RN中的ScrollView和Android中的ScrollView控件概念基本相同。but,如下 ScrollView最适合展示少量有限尺寸的东西。 ScrollView的所有元素和视图都将被渲染，即使它们当前未显示在屏幕上。如果您有更长的项目列表可以在屏幕上，您应该使用ListView代替。 ScrollView渲染视图，会全部渲染。所以使用需要谨慎，防止过度渲染。 123456789101112131415161718192021222324252627282930313233343536/********-----------------scrollview--------------------******///会渲染过度 推荐使用listviewimport React, &#123;Component&#125; from 'react';import &#123;AppRegistry, Text, Image, ScrollView&#125; from 'react-native';class IScrolledDownAndWhatHappenedNextShockedMe extends Component &#123; render() &#123; return ( &lt;ScrollView&gt; &lt;Text style=&#123;&#123;fontSize: 20&#125;&#125;&gt;Scroll me&lt;/Text&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Text style=&#123;&#123;fontSize:20&#125;&#125;&gt;If you like&lt;/Text&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Text style=&#123;&#123;fontSize:20&#125;&#125;&gt;If you like&lt;/Text&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125; style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/img/logo_og.png'&#125;&#125;style=&#123;&#123;width: 40, height: 40&#125;&#125;/&gt; &lt;/ScrollView&gt; ); &#125;&#125;AppRegistry.registerComponent('FirstRNProject', () =&gt; IScrolledDownAndWhatHappenedNextShockedMe); gif图录制没搞，暂时就不放图 ListView 金风玉露一相逢,便胜却人间无数 as you think.RN的ListView和Android的listView概念相似。同样需要数据源（dataSource），和解析数据并展示到条目（renderRow）。同时，在初始化ListView的时候，你需要监听rowHasChanged函数，来判断某行数据是否变化，这是必须的属性。当然，你可以发挥你的想象，在Andorid中ListView的属性，都可以移植到RN当中来。至于，具体的用法，会在后面的具体项目中进行实践，敬请期待！ 废话不多说，代码上见，如下 1234567891011121314151617181920212223242526272829303132/************-------------------listview---------------*******/import React, &#123;Component&#125; from 'react';import &#123;AppRegistry, Text, Image, ListView, View&#125; from 'react-native';class ListViewBasics extends Component &#123; constructor(props) &#123; super(props); const ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;); this.state = &#123; dataSource: ds.cloneWithRows([ 'xyx', 'hl', 'yxix', 'lh', 'yxiac', 'yxxiac' ]) &#125;; &#125; render() &#123; return ( &lt;View style=&#123;&#123;flex:1, paddingTop: 22&#125;&#125;&gt; &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;(rowData, rowId) =&gt; &lt;Text style=&#123;&#123;height: 500&#125;&#125;&gt;&#123;rowData+rowId&#125;&lt;/Text&gt;&#125;/&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('FirstRNProject', () =&gt; ListViewBasics); gif图录制没搞，暂时就不放图 //TODO 相同的数据在ListView和ScrollView中过渡渲染的效果展示 NetWorkReact Native提供了和web标准一致的Fetch API，so，you need look fetch. 12345678910111213141516171819202122232425262728/************------------------network------------------*********/import React, &#123;Component&#125; from 'react';import &#123;AppRegistry, ListView, Text, View&#125; from 'react-native';getMoviesFromApiAsync()&#123; return fetch('https://facebook.github.io/react-native/movies.json') .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; return responseJson.movies; &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;);&#125;// //ES7语法// async getMoviesFromApi()// &#123;// try &#123;// let response = await fetch('https://facebook.github.io/react-native/movies.json');// let responseJson = await response.json();// return responseJson.movies;// &#125; catch (error) &#123;// console.error(error);// &#125;// &#125; 代码如上图，其中的.then是因为使用fethc()会返回一个Promise,即简化异步风格的代码。这里有木有和RxJava很像呀😀 其他刚开始写RN系列，是想分享下自己的学习过程，但是写到这里渐渐发现，如果继续按照此步骤写下去，感觉就有点乏善可陈。同样一门新技术的学习，必不可少的是练习练习再练习，不敢保证所有人都是通过练习来学习的，但是至少百分之95的人都是这样的。毕竟，如果一味的看别人的教程，在实际遇到的情况下，大部分人都是哈希蒙蔽。所以，接下来，本站RN系列准备出一个实战的RN项目，作为此系列的终章，希望大家新技术玩的开心，敬请期待！么么哒~]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>webApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作生活杂记]]></title>
    <url>%2F2017%2F05%2F17%2F%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。 骚年，是不是以为我要吐槽，其实只想说一句话：态度决定高度，格局决定结局~ 工作生活中，一定要及时调整自己的态度。时刻反省，明确的知道自己想要什么。]]></content>
      <categories>
        <category>鸡汤</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native入门到怀疑人生（四）]]></title>
    <url>%2F2017%2F05%2F12%2FReact-Native%E5%85%A5%E9%97%A8%E5%88%B0%E6%80%80%E7%96%91%E4%BA%BA%E7%94%9F%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[欢迎收听React Native系列，基于Window10,偏向于Android端的React Native。上一章React Native入门到怀疑人生（三）我们已经讲解了RN的props属性，state状态，样式相关知识，那么本章节将讲解RN的flexbox布局，控件宽高相关知识。本章将使用ES6语法。文章不当之处，希望大家不吝赐教，多谢！ 宽高组件的宽高，这里可以理解为Android中控件的宽高，宽和高决定了控件大小。Android中的宽高使用的单位为dp（独立像素密度）,而RN中的宽高无单位。表示了与设备像素密度无关的逻辑像素点。 1234567891011121314151617/**-----width height--------****/import React, &#123;Component&#125; from 'react';import &#123;AppRegistry, Text, View&#125; from 'react-native';class FixDimensionsBasics extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125;/&gt; &lt;View style=&#123;&#123;width: 100, height: 100, backgroundColor: 'skyblue'&#125;&#125;/&gt; &lt;View style=&#123;&#123;width: 150, height: 150, backgroundColor: 'steelblue'&#125;&#125;/&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('FirstRNProject', ()=&gt;FixDimensionsBasics); 运行结果如下图 backgroundColor参考 https://facebook.github.io/react-native/docs/colors.html flex布局flex属性可参考android中linearLayout的layout_weight属性。在RN组件中使用flex属性，可以使其在可利用的空间中动态地扩张或收缩。 组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。 使用flex来布局React Native中使用flexbox规则来指定某个组件的子元素的布局。Flexbox可以在不同屏幕尺寸上提供一致的布局结构。通常使用flexDirection，alignItems和justifyContent的组合来实现正确的布局。在使用flex布局时候，可配合flexDirection，alignItems和justifyContent一起来实现控件子元素的布局 Flex Direction在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。 123456789101112131415161718// /**--------------使用flexbox布局--------------**/import React, &#123;Component&#125; from 'react';import &#123;AppRegistry, Text, View&#125; from 'react-native';class FlexDirecitonBasics extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;flex:1, flexDirection: 'row'&#125;&#125;&gt; &lt;View style=&#123;&#123;width: 50, backgroundColor: 'powderblue'&#125;&#125;/&gt; &lt;View style=&#123;&#123;width: 50, backgroundColor: 'skyblue'&#125;&#125;/&gt; &lt;View style=&#123;&#123;width: 50, backgroundColor: 'steelblue'&#125;&#125;/&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('FirstRNProject', ()=&gt; FlexDirecitonBasics); 运行结果如下图 Justify Content在组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：flex-start、center、flex-end、space-around以及space-between。 1234567891011121314151617181920212223// /**--------------使用flexbox布局--------------**/import React, &#123;Component&#125; from 'react';import &#123;AppRegistry, Text, View&#125; from 'react-native';class FlexDirecitonBasics extends Component &#123; render() &#123; return ( // 尝试把`justifyContent`改为`center`看看 // 尝试把`flexDirection`改为`row`看看 &lt;View style=&#123;&#123; flex: 1, flexDirection: 'column', justifyContent: 'space-between', &#125;&#125;&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125;/&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'skyblue'&#125;&#125;/&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'steelblue'&#125;&#125;/&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('FirstRNProject', () =&gt; FlexDirecitonBasics); 运行结果如下图 Align Items在组件的style中指定alignItems可以决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：flex-start、center、flex-end以及stretch。 1234567891011121314151617181920212223242526// /**--------------使用flexbox布局--------------**/import React, &#123;Component&#125; from 'react';import &#123;AppRegistry, Text, View&#125; from 'react-native';class FlexDirecitonBasics extends Component &#123; render() &#123; return ( // 尝试把`alignItems`改为`flex-start`看看 // 尝试把`justifyContent`改为`flex-end`看看 // 尝试把`flexDirection`改为`row`看看 &lt;View style=&#123;&#123; flex: 1, flexDirection: 'column', justifyContent: 'center', alignItems: 'center', &#125;&#125;&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('FirstRNProject', ()=&gt; FlexDirecitonBasics); 运行结果如下图 关于flex相关属性，大家可以多多尝试，敲出不同的代码，来验证效果。读万卷书，敲万行代码。比如大家可以尝试实现如下效果 总结 1 组件的style中指定flexDirection可以决定布局的主轴沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列,默认值是竖直轴(column)方向 2 组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布?flex-start、center、flex-end、space-around以及space-between 3 组件的style中指定alignItems可以决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？flex-start、center、flex-end以及stretch 文章不当之处请及时指出。周末朋友来南京，拖更啦~~~ ##参考资料 FaceBook.github ReactNative 中文网]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>webApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View事件分发的反思]]></title>
    <url>%2F2017%2F05%2F11%2FView%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%9A%84%E5%8F%8D%E6%80%9D%2F</url>
    <content type="text"><![CDATA[Activity的dispatchTouchEvent(MotionEvent ev)和onTouchEvent(MotionEvent ev)方法的来源引发的思考，本文不侧重于讲解View事件的分发机制！不当之处，请及时指出，谢谢。 问题 在Activity override的方法中，存在的onTouchEvent(MotionEvent ev)和dispatchTouchEvent(MotionEvent ev)来源是哪里？ View事件分发机制回顾Android界面是有View和ViewGroup构成的。正如大家所了解的一样：View和ViewGroup的事件分发机制有部分的差别。 事件序列是指从手指触碰屏幕的那一刻起，到手指离开屏幕那一刻结束，在这个过程中产生的一系列事件，以down事件开始，中间含有数量不定的move事件，最终以up事件结束。 dispatchTouchEvent(MotionEvent ev)用来进行事件的分发，如果时间传递到当前的View，那么此方法一定会被调用，返回的结果受当前View的onTouchEvent和下级view的dispatchTouchEvent方法影响。 onInterceptTouchEvent(MotionEvent ev)View没有此方法，所以一旦有点击事件传递给它，那么它的OnTouchEvent方法就会被调用。ViewGroup中，在接收到dispatchTouchEvent后，在其内部会调用此方法，用来判断是否拦截当前事件，如果拦截，那么在同一个事件序列中，此方法不会被调用。 onTouchEvent(MotionEvent ev)在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则无法z再次接受当前事件序列。 解决问题正如了解到的事件发生首先传递给当前的Activity，由Activity的dispatchTouchEvent,来进行分发。那么我们来查看Actvity中的dispatchTouchEvent方法，Activity源码如下图: 通过源码查看发现，Activity调用的是Window中的dispatchTouchEvent方法。接着查找OnTouchEvent 透过源码问题1的答案，显而易见了，activity的onTouchEvent和dispatchTouchEvent来源与window。 那么window又是如何处理的呢？ 通过源码我们发现window是抽象类，同时他的superDispatchTouchEvent也是抽象方法，如图 那么我们就需要找到他的实现类，通过查看Window源码发现，它只有一个实现类为PhoneWindow,如图 其实window是通过View的形式展现的，一个window对应这一个View和ViewRootImpl,如果有兴趣可以查看源码，这里不做叙述，收。 接着上面我们查找PhoneWindow中的superDispatchTouchEvent方法如图 发现PhoneWindow调用的是mDecor，即DecorView.也就是说PhoneWindow将事件直接传递给了DecorView,那么我们接着了解下DecorView 通过源码发现DecorView为顶级View即界面的根布局，同时由于DecorView继承自FrameLayout,而且是根布局，所以最终的事件会分发到界面中的根布局(DecorView)，然后由根布局向我们添加的View分发，至此，Touch事件完美的分发下去了。 最后：本文不侧重与探讨View事件的分发机制。旨在分享遇到问题时的解决方案。That`s All! 文章若有不当之处，请及时指出，谢谢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>事件分发</tag>
        <tag>ViewTouch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native入门到怀疑人生（三）]]></title>
    <url>%2F2017%2F05%2F09%2FReact-Native%E5%85%A5%E9%97%A8%E5%88%B0%E6%80%80%E7%96%91%E4%BA%BA%E7%94%9F%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[欢迎收听React Native系列，基于Window10,偏向于Android端的React Native。上一章React Native入门到怀疑人生（二）我们已经成功运行了官方Demo，介绍了React.js、ES6相关学习资料，推荐了开发RN的编辑器，那么本章节将讲解RN的props属性，state状态，样式相关知识。本章将使用ES6语法。请各位系好安全带，本章节我们将真正开始RN的开发。嘀！老年卡。文章不当之处，希望大家不吝赐教，多谢！ 准备工作 新建一个react Project，用于我们本章内容讲解note:react-native init &quot;ProjectName&quot; webstorm安装RN提示插件 使用webstorm打开， Props（属性）讲解组件（可以理解为Android的控件）在创建的时候，我们都会赋予相应的参数，这些参数就相当于props(属性)，还是上代码吧，代码理解起来简单点。 12345678910111213141516171819202122232425/* *-------------props-------------**/import React, &#123;Component&#125; from 'react';/** * ES6语法，等价与ES5中的 * var AppRegistry = require('./AppRegistry'); */import &#123;AppRegistry, Image&#125; from 'react-native';class HelloReact extends Component &#123; render() &#123; let pic = &#123; uri: 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg' &#125;; /** * source就是定义的属性名称，同时通过定义的pic变量给它赋值，控制展示的图片资源 * 通过style的props来控制图片的尺寸 */ return( &lt;Image source= &#123;pic&#125; style = &#123;&#123;width : 500 , height: 500&#125;&#125;/&gt; ); &#125;&#125;AppRegistry.registerComponent('FirstRNProject', () =&gt; HelloReact); 代码中已添加注释 代码中的{ { pic } }是JSX语法,JSX语法的基本规则如下 1 遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析 2 JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员 3 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求(可以了解下) 代码中的 import {AppRegistry, Image} from &#39;react-native&#39;为ES6语法等价与ES5中的var AppRegistry = require(&#39;./AppRegistry&#39;) 代码中registerComponent()方法的第一个参数&#39;FirstRNProject&#39;必须和android\app\src\main\java\com\firstrnproject\MainActivity类中的getMainComponentName()方法返回的String保持一致 state（状态）讲解 我们使用两种数据来控制一个组件：props和state。props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。 对于需要改变的数据，我们需要使用state。 一般来说，你需要在constructor中初始化state（译注：这是ES6的写法，早期的很多ES5的例子使用的是getInitialState方法来初始化state，这一做法会逐渐被淘汰），然后在需要修改时调用setState方法。 假如我们需要制作一段不停闪烁的文字。文字内容本身在组件创建时就已经指定好了，所以文字内容应该是一个prop。而文字的显示或隐藏的状态（快速的显隐切换就产生了闪烁的效果）则是随着时间变化的，因此这一状态应该写到state中。 摘自ReactNative中文网，这段话对state的描述非常透彻。这里补充一点getInitialState方法在很多现有的库中发现此类写法，其实就是对state进行赋值的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/**---------------- state------------**/import React, &#123;Component&#125; from 'react';import &#123;AppRegistry, Text, View&#125; from 'react-native';class Blink extends Component &#123; constructor(props) &#123; super(props); //初始化状态值 this.state = &#123; showText : true&#125;; //开启定时任务，隔1s取反状态值 setInterval(() =&gt; &#123; this.setState(previousState =&gt; &#123; return &#123;showText:!previousState.showText&#125;; &#125;) &#125;, 1000); &#125; render() &#123; let display = this.state.showText? this.props.text:''; return ( // 根据当前showText的值决定是否显示text内容，布局会根据属性值自动重新渲染text &lt;Text&gt;&#123;display&#125;&lt;/Text&gt; ); &#125;;&#125;class BlinkApp extends Component&#123; render() &#123; return( &lt;View&gt; &lt;Blink text = 'I Love You'/&gt; &lt;Blink text = 'I Love You'/&gt; &lt;Blink text = 'I Love You'/&gt; &lt;Blink text = 'I Love You'/&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('FirstRNProject', () =&gt; BlinkApp); 代码中的=&gt;箭头函数为ES6语法可参考下面代码1234567891011121314151617// ES5 var selected = allJobs.filter(function (job) &#123; return job.isSelected(); &#125;); // ES6 var selected = allJobs.filter(job =&gt; job.isSelected()); ~~~~~~/ ES5 $("#btn").click(function (event) &#123; dosomeing.... &#125;); // ES6 $("#btn").click(event =&gt; &#123; dosomeing....&#125;); 😂不会录gif,后期补充 样式 在React Native中，你并不需要学习什么特殊的语法来定义样式。我们仍然是使用JavaScript来写样式。所有的核心组件都接受名为style的属性。这些样式名基本上是遵循了web上的CSS的命名，只是按照JS的语法要求使用了驼峰命名法，例如将background-color改为backgroundColor。 style属性可以是一个普通的JavaScript对象。这是最简单的用法，因而在示例代码中很常见。你还可以传入一个数组——在数组中位置居后的样式对象比居前的优先级更高，这样你可以间接实现样式的继承。 实际开发中组件的样式会越来越复杂，我们建议使用StyleSheet.create来集中定义组件的样式。比如像下面这样 1234567891011121314151617181920212223242526272829/****--------------------style-------------**/import React, &#123;Component&#125; from 'react';import &#123;AppRegistry, StyleSheet, Text, View&#125; from 'react-native';class LostOfStyles extends Component &#123; render() &#123; return( &lt;View&gt; &lt;Text style=&#123;style.bigblue&#125;&gt;bigblue&lt;/Text&gt; &lt;Text style=&#123;style.red&#125;&gt;red&lt;/Text&gt; &lt;Text style=&#123;[style.red, style.bigblue]&#125;&gt;red, then bigblue&lt;/Text&gt; &lt;Text style=&#123;[style.bigblue, style.red]&#125;&gt;bigblue, then red&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;//按顺序声明和使用style属性const style = StyleSheet.create(&#123; bigblue: &#123; color: 'blue', fontWeight: 'bold', fontSize: 30, &#125;, red: &#123; color:'red', &#125;,&#125;);AppRegistry.registerComponent('FirstRNProject', ()=&gt; LostOfStyles); 样式基本使用和JavaScript里面的使用一样，暂时不做赘述。 ##参考资料 FaceBook.github ReactNative 中文网]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>webApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存优化]]></title>
    <url>%2F2017%2F05%2F09%2FAndroid%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[本章参考google官方文档，总结了android开发过程中内存优化的方法，同时，结合实际开发过程中遇到的OOM，总结了部分经验。不当之处，请随时提出。 Random-access memory (RAM) is a valuable resource in any software development environment,but it’s even more valuable on a mobile operating system where physical memory is often constrained.Although both the Android Runtime (ART) and Dalvik virtual machine perform routine garbage collection,this does not mean you can ignore when and where your app allocates and releases memory 随机存取存储器（RAM）是任何软件开发环境中的宝贵资源，但在物理内存通常受限制的移动操作系统上更为有价值。尽管Android Runtime（ART）和Dalvik虚拟机都执行常规垃圾收集，但这并不意味着您可以忽略应用程序分配和释放内存的时间和位置 查看内存使用情况 1 使用android studio自带的 Memory Monitor查看该工具显示可用和分配的Java内存随时间的图，包括垃圾回收事件 2 使用android studio自带的allocation Tracker tool 分配跟踪器记录应用程序的内存分配，并列出分析快照中的所有已分配对象。您可以使用此工具来跟踪分配太多对象的部分代码 优化内存的方案1 使用onTrimMemory在应用UI隐藏时释放UI资源来释放内存请注意：这个玩意不同于onStop，你的应用仅仅会在所有UI组件的被隐藏的时候接收到onTrimMemory()的回调并带有参数TRIM_MEMORY_UI_HIDDEN。这与onStop()的回调是不同的，onStop会在activity的实例隐藏时会执行， 例如当用户从你的app的某个activity跳转到另外一个activity时前面activity的onStop()会被执行。因此你应该实现onStop回调，并且在此回调里面释放activity的资源，例如释放网络连接，注销监听广播接收者。除非接收到onTrimMemory(TRIM_MEMORY_UI_HIDDEN))的回调，否者你不应该释放你的UI资源。这确保了用户从其他activity切回来时，你的UI资源仍然可用，并且可以迅速恢复activity。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import android.content.ComponentCallbacks2;// Other import statements ...public class MainActivity extends AppCompatActivity implements ComponentCallbacks2 &#123; // Other activity code ... /** * Release memory when the UI becomes hidden or when system resources become low. * @param level the memory-related event that was raised. */ public void onTrimMemory(int level) &#123; // Determine which lifecycle or system event was raised. switch (level) &#123; case ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN: /* Release any UI objects that currently hold memory. The user interface has moved to the background. */ break; //你的app正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制 case ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE: break; //你的app正在运行且没有被列为可杀死的。但是设备正运行于更低内存的状态下，你应该释放不用的资源用来提升系统性能（但是这也会直接影响到你的app的性能）。 case ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW: break; //你的app仍在运行，但是系统已经把LRU Cache中的大多数进程都已经杀死，因此你应该立即释放所有非必须的资源。如果系统不能回收到足够的RAM数量， //系统将会清除所有的LRU缓存中的进程，并且开始杀死那些之前被认为不应该杀死的进程，例如那个包含了一个运行态Service的进程。 case ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL: /* Release any memory that your app doesn't need to run. The device is running low on memory while the app is running. The event raised indicates the severity of the memory-related event. If the event is TRIM_MEMORY_RUNNING_CRITICAL, then the system will begin killing background processes. */ break; //系统正运行于低内存状态并且你的进程正处于LRU缓存名单中最不容易杀掉的位置。尽管你的app进程并不 是处于被杀掉的高危险状态， //系统可能已经开始杀掉LRU缓存中的其他进程了。你应该释放那些容易恢复的资源，以便于你的进程可以保留下来，这样当用户回退到你的app的时候才能够迅速恢复。 case ComponentCallbacks2.TRIM_MEMORY_BACKGROUND: break; //系统正运行于低内存状态并且你的进程已经已经接近LRU名单的中部位置。如果系统开始变得更加内存紧张，你的进程是有可能被杀死的 case ComponentCallbacks2.TRIM_MEMORY_MODERATE: break; //系统正运行与低内存的状态并且你的进程正处于LRU名单中最容易被杀掉的位置。你应该释放任何不影响你的app恢复状态的资源 case ComponentCallbacks2.TRIM_MEMORY_COMPLETE: /* Release as much memory as the process can. The app is on the LRU list and the system is running low on memory. The event raised indicates where the app sits within the LRU list. If the event is TRIM_MEMORY_COMPLETE, the process will be one of the first to be terminated. */ break; default: /* Release any non-critical data structures. The app received an unrecognized memory level value from the system. Treat this as a generic low-memory message. */ break; &#125; &#125;&#125; 这个回调支持API14以上，要兼容14以下可以使用 onLowMemory() 2 谨慎使用services,可以选择intentservice 代替service 它会在处理完交代给它的intent任务之后尽快结束自己 3 使用ArrayMap/SparseArray代替hashmap等传统数据结构4 注意代码抽象，少用enum抽象的代价是巨大的：一般来说，它们需要更多的代码需要执行，需要更多的时间和更多的RAM才能将该代码映射到内存中 For example, enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android 5 谨慎使用第三方库，移除内存使用大的库和资源文件 你的代码中的一些资源和库可以在不知道的情况下消除内存。 您的APK的总体尺寸（包括第三方库或嵌入式资源）可能会影响应用程序消耗多少内存。 您可以通过从代码中删除任何冗余的，不必要的或膨胀的组件，资源或库来提高应用程序的内存消耗 6 减小APk大小 您可以通过减少应用程序的总体大小来显着降低应用程序的内存使用量。 位图大小，资源，动画框架和第三方库都可以帮助您的APK的大小。 Android Studio和Android SDK提供多种工具来帮助您减少资源和外部依赖关系的大小 example Reduce APK Size 7 如果项目必须需要用到依赖注入框架，推荐使用Dragger2(官方推荐) Dagger不使用反射来扫描您的应用程序的代码。 Dagger的静态编译时实现意味着它可以在Android应用程序中使用，而无需运行时费用或内存使用。 8 使用LeakCanary开源控件，可以很好的帮助我们发现内存泄露的情况 具体的使用请查看官方Github或者中文资料 当然还可以使用MAT 以上参考自android官方性能优化资料 总结 LeakCanary值得推荐，用于监听项目中的内存泄露。监听会发现除了官方SDK中的方法导致的内存泄露外，大部分都是静态变量的引用未及时销毁导致的。 加载大图，及易产生OOM。因此在加载图片的时候，需要我们对图片进行压缩处理（图片的大小，质量压缩），选择合适尺寸的图片进行加载。同时，需要及时recycle临时图片。 减少不必要的全局变量（官方文档给出了同样的建议），避免静态变量引用消耗更多的资源。 减少枚举类型的使用。 在使用SQLite时及时销毁cursor。 以上为项目中遇到的内存优化方案，其他方案若有遗漏会及时补充。 插一句：虽然现在手机内存慢慢在变大，必要的时候，我们可以使用空间换时间，但是在自己能力范围内，不断的优化内存使用，应该算是我们的职业道德吧👍。 虽然我现在是渣渣，但是五年后呢？嘻嘻]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native入门到怀疑人生（二）]]></title>
    <url>%2F2017%2F05%2F08%2FReact-Native%E5%85%A5%E9%97%A8%E5%88%B0%E6%80%80%E7%96%91%E4%BA%BA%E7%94%9F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[欢迎收听React Native系列，基于Window10,偏向于Android端的React Native。上一章React Native入门到怀疑人生（一）我们已经成功将RN配置环境搭建完成，本章节将讲解如何下载并运行FB提供的官方Demo，React.js学习，ES6语法相关学习，以及开发RN的编辑器推荐。请各位系好安全带，本章节过后我们将真正开始RN的开发。嘀！老年卡。文章不当之处，希望大家不吝赐教，多谢！ 官方Demo的下载和运行1 下载RN源码若已经安装过项目源码（只要你配置过RN环境基本上都已经克隆过源码，这里只是演示克隆步骤）可跳过此步骤，直接进入项目根目录输入npm install在当前文件夹安装项目依赖，然后跳过此步骤 选择需要安装的目录，新建文件夹，进入文件夹，点击右键在弹出界面中点击Git Bash Hell打开Git命令行，输入git clone https://github.com/facebook/react-native.git，等待下载。 , 安装完成后，界面目录如图。 . 接着，在命令行中输入cd react-native &amp;&amp; npm install。等待安装项目依赖。 2 运行Android ExampleNote that you’ll need the Android NDK installed, see prerequisites. 如上所述，在运行Android项目之前，你需要安装Android NDK,并且配置NDK环境变量。 Make sure you have the following installed: Android SDK version 23 (compileSdkVersion in build.gradle) SDK build tools version 23.0.1 (buildToolsVersion in build.gradle) Android Support Repository &gt;= 17 (for Android Support Library) Android NDK (download links and installation instructions below) 其实上述我们需要关注的只是Android NDK，RNDemo依赖的版本为Android NDK, Revision 10e (May 2015).点击下载相应的NDK版本。（不需要翻墙~.~!）. 配图只是想表达下我的网速😁下载完成之后，选择需要解压的目录，我这边放在sdk目录下如图，当前你可以随意 解压之后，记得要将NDK添加到环境变量中,如：（ANDROID_NDK =&gt; D:\sdk\android-ndk-r10e; Path =&gt; %ADNROID_NDK%） 修改环境变量后，请重新打开命令行，才能生效 至此配置基本完成，下面打开你的饭碗。。。你，就是说你的，是让你打开你的android模拟器（或者真机），你拿个吃饭的碗干嘛！ 在项目根目录（E:\RNDemo\react-native）打开git，输入./gradlew :Examples:UIExplorer:android:app:installDebug，等待安装。（需要翻下墙，翻墙姿势请参考上一章React Native入门到怀疑人生（一））安装完成后你会发现在手机上UIExplore App已成功安装如图。 但是这个时候如果点击app打开会报错如图 这个时候我们需要输入./packager/packager.sh，启动packger server,然后在真机或模拟器上打开我们的应用。成功启动界面如图 Demo中展示有RN的基本组件可以点击浏览。可以点击查看，当然可以在源码中找到相应的控件学习下，这就是接下来的系列教程将会讲解的相关控件。 RN编辑器推荐 Nuclide是Facebook内部所使用的React Native开发工具。它最大的特点是自带调试功能，并且非常好地支持flow语法规则。（译注：然而我们还是推荐webstorm或是sublime text）。 Ignite是一套整合了Redux以及一些常见UI组件的脚手架。它带有一个命令行可以生成app、组件或是容器。如果你喜欢它的选择搭配，那么不妨一试。 CodePush是由微软提供的热更新服务。热更新可以使你绕过AppStore的审核机制，直接修改已经上架的应用。对于国内用户，我们也推荐由本网站提供的Pushy热更新服务，相比CodePush来说，提供了全中文的文档和技术支持，服务器部署在国内速度更快，还提供了全自动的差量更新方式，大幅节约更新流量，欢迎朋友们试用和反馈意见！ Exponent是一套开发环境，还带有一个已上架的空应用容器。这样你可以在没有原生开发平台（Xcode或是Android Studio）的情况下直接编写React Native应用（当然这样你只能写js部分代码而没法写原生代码）。 Deco是一个专为React Native设计的集成开发环境。它可以自动创建新项目、搜索开源组件并插入到项目中。你还可以实时地可视化地调整应用的界面。不过目前还只支持mac。 由于win10系统所以这里选择的开发工具为webstorm。 webstorm开发工具编辑RN代码提示功能可按照下列步骤 1 进入你想存储这个文件的目录，按住shift+鼠标右键，选择“在此处打开命令窗口” 2 在命令窗口中输入 git clone https://github.com/virtoolswebplayer/ReactNative-LiveTemplate 3 打开webstorm， 选择file–&gt;Import Settings…–&gt;在刚刚下载的文件夹里找到ReactNative.jar选择它–&gt;OK 4 提示重启webstrom，重启，搞定 RN使用ES6语法，所以我们可以开启webstorm对ES6语法的支持，步骤如下 1 我们一定要下载最新版本的11.0.3 webstorm，只有这个版本才能更好的兼容ES6特性。 2 设置JavaScript语言版本：Preferences &gt; Languages &amp; Frameworks &gt; JavaScript Rect.js学习推荐阮一峰老师的react.js快速入门教程。Rect.js不再展开讲解，后面课程会穿插讲解部分 ES6语法同样的，推荐阮一峰老师的ES6教程。ES6不再展开讲解，后面课程会穿插讲解部分 其他资料 If you have a good command of English,Then you can look at other people carefully sorted out the list of resources 当然还有中文的参考资料 感谢github👍，顺便给大家看一场撕逼大战😎 ##参考资料 FaceBook.github ReactNative 中文网]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>webApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native入门到怀疑人生（一）]]></title>
    <url>%2F2017%2F05%2F07%2FReact-Native%E5%85%A5%E9%97%A8%E5%88%B0%E6%80%80%E7%96%91%E4%BA%BA%E7%94%9F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[欢迎收听React Native系列，基于Window10,偏向于Android端的React Native。从入门到怀疑人生，对！没错怀疑人生就是我现在的状态😇。文章不当之处，希望大家不吝赐教，多谢！ Windows版本React Native环境配置1 安装JDk下载jdk1.8以上版本，安装并配置相应环境变量.验证是否正确安装打开命令行，输入java -version验证. 2 安装Android Studioandroid stuido,若初次下载，可选择包含Android SDK的下载版本。 3 配置SDK环境变量找到SDK的安装目录，设置sdk环境变量,并将其加入环境变量PATH中，例如（ANDROID_HOME=&gt; E:\Android\sdk）（PATH=&gt; %ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools）。 4 设置SDk打开android在SDK Platforms窗口中，选择Show Package Details，然后 在Android 6.0 (Marshmallow)中勾选Google APIs、Android SDK Platform 23、Intel x86 Atom System Image、Intel x86 Atom_64 System Image以及Google APIs Intel x86 Atom_64 System Image。 在SDK Tools窗口中，选择Show Package Details，然后在Android SDK Build Tools中勾选Android SDK Build-Tools 23.0.1（必须是这个版本）。然后还要勾选最底部的Android Support Repository. 5 安装Githttps://git-for-windows.github.io/版本控制工具，下面步骤直接可以使用git下载相应配置文件 6 安装nodeReact Native运行是基于node.js,所以请下载node安装完成之后，验证是否正常安装，可打开命令行输入node -v验证 7 克隆项目并安装命令行工具react-native-cli选择需要安装的目录，新建文件夹,进入文件夹点击右键，在弹出界面中点击Git Bash Hell打开Git命令行,输入git clone https://github.com/facebook/react-native.git，等待下载 安装成功后界面文件目录如图 输入npm install -g react-native-cli 安装命令行工具 进入刚刚目录下的react-native目录下的react-native-cli目录，输入npm install -g(可以使用Git Bush Hell命令行，也可以使用CMD)全局安装脚手架工具 8 创建第一个RN项目选择需要安装的目录，输入react-native init FirstRNProject，等待一段时间，安装成功目录如下 9 运行RN项目需要的服务在新创建的项目根目录下，输入react-native start（可使用Git,也可使用CMD）启动成功后，可以用浏览器访问[](http://localhost:8081/index.android.bundle?platform=android)，如果可以访问表示服务器端已经可以了. 10 运行项目前提：需要有设备连接在电脑或打开模拟器（使用genymotion的话，需要z在设置中修改SDK为android sdk） 重新打开命令行（Git或CMD）,定位到新创建的项目根目录下，输入react-native run-android（如果报错请检查Andorid环境变量、Android SDK的设置是否按照本文上方的SDK设置，全部添加） 如果模拟器或真机出现红色报错界面，可进入Dev开发者选项（Ctrl+M或者菜单键，在弹出框中选择Dev Seting,下图中位置，在对话框中输入本地IP+服务端口号，例如：192.168.1.66：8081，ip为我本机的Ip 端口可查看react-native start命令窗口的端口号，默认为8081） 至此，RN的环境配置及创建运行第一个项目已全部完成。 成功运行的界面如下 感觉没有写什么东西🤸🤸🤸 结束好吧 如果上述步骤需要翻墙的话，推荐使用latern,或者修改Host老刀Host提到Host就要感谢下胖叔叔教会的翻墙姿势😜 有疑问欢迎留言。 ##参考资料 FaceBook.github ReactNative 中文网]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>webApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动web相关技术浅析]]></title>
    <url>%2F2017%2F05%2F06%2F%E7%A7%BB%E5%8A%A8web%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[最近预研了许多webApp相关知识，包括H5+，mui,react native相关知识，觉得有必要写下部分感悟，因此诞生了此篇文章，不足之处，请大家及时指出，希望能对有同样需求的你带来帮助. 使用前端开发app方法 适应移动端的网页bootstrap、amazeui、eg. 使用html5+jss+css+打包技术开发Cordova（phoneGap） 这个玩意比较重量级,不过反编发现还是有部分app是这种开发模式的Hbuilder（一种编译工具 提供有app的开发API html5+ 以及UI框架 mui） React Native Weex webApp vs hybirdApp vs nativeAppNative App的优势 提供最佳的用户体验，最优质的用户界面，最华丽的交互 针对不同平台提供不同体验 可节省带宽成本 可访问本地资源 盈利模式明朗 Native App的劣势 移植到不同平台上比较麻烦 维持多个版本的成本比较高 需要通过store或market的确认 Web App的优势 开发成本低 适配多种移动设备成本低 适配多种移动设备成本低 迭代更新容易 无需安装成本 Web App的劣势 浏览的体验短期内还无法超越原生应用 不支持离线模式(html5将会解决这个问题) 消息推送不够及时 消息推送不够及时 如何选择 偏交互的native, 偏浏览的web（交互是指复杂的操作） 已稳定的native, 试错中的web（h5开发成本比原生低） 访问硬件native, 信息展示Web（当然现在有框架可以直接调用原生设备） 核心功能native, 辅助性的web 上述摘自知乎 其实上面都是废话 了解就可，闲的话可以研究下 🙃 介绍下Hbuilder由于之前项目使用需求使用Hbuilder进行开发 所以下面就大概讲解下Hbuilder开发的相关知识。 原理 html负责页面，也就是的内容和框架； js负责调用方法，也就是调用一些移动端原生； ui负责样式，比较有名的bootstrap，amazeui，jQuery mobile，mui 下面是ui选用mui的一个的项目结构 Common包下为项目使用到的一些样式（mui.css），字体样式（fonts），和一些mui框架提供的一些控件需要用到的js和cssImg包下为使用的图片资源 Models包下为当前项目的不同模块，项目的界面和逻辑处理就在这个包下 Index为项目默认的应用入口界面 Manifest为项目图标权限使用的原生的引用相关的配置 初始化创建的项目目录结构可能和上面例子有差别，你可以自己重新构建这个就看公司要求和个人习惯。 至于用法请查看w3c和hbuilder.相关技术不在本篇博客讨论范围. 需要wechat muiApp项目源码请留言. 后续将会发布相关React Native相关开发经验。That`s All. Q: 使用h5页面开发app吧，这样不用发版本界面就能更新呀。 A: 😷 不好意思你说的loadUrl.]]></content>
      <categories>
        <category>鸡汤</category>
      </categories>
      <tags>
        <tag>webApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Mrx`s Blog! This is my very first post. Thank you for your visit!From this, the unity of knowledge and action]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>欢迎</tag>
      </tags>
  </entry>
</search>